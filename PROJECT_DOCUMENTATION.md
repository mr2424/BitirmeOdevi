BitirmeOdevi - Benzerlik Analiz Sistemi
======================================

Bu proje, ogrenci odevleri arasinda kopya ve benzerlik tespiti yapmak icin tasarlanmis, coklu format (PDF/DOCX/TXT) destekli bir analiz uygulamasidir. Uygulama calistiginda `main.py` arayuzu baslatir ve tum is akisi `app/gui.py` ile `app/similarity_app.py` arasinda yonetilir. Kullanici arayuzden klasor secer, sistem o klasordeki dokumanlari `core/document_processor.py` uzerinden uygun extractor ile okur ve gerekli metni cikarir. PDF icin metin katmani okunur, gorsel icerik varsa ve OCR aciksa `core/ocr_motoru.py` ile TrOCR modeli kullanilarak metin elde edilir. DOCX ve TXT icin extractorlar dogrudan metni alir, temizler ve analiz icin hazirlar. Metinler bellekte tutulur, analiz islemine gecildiginde tum dosya ciftleri olusturulur ve her cift icin benzerlik skoru hesaplanir.

Benzerlik hesaplama `core/analiz_motoru.py` icinde yapilir. Burada iki ana skor vardir: lexical skor, TF‑IDF ve cosine similarity ile bulunur; semantic skor ise SentenceTransformer ile elde edilen embeddinglerin cosine benzerligiyle hesaplanir. Bu iki skor config uzerinden gelen agirliklarla birlestirilir ve final skor uretilir. Final skor, `config.json` icinde tanimlanan esiklere gore etiketlenir: final kopya esigini gecerse "KOPYA", supheli esigini gecerse "SUPHELI", aksi durumda "TEMIZ". Kullanici arayuzden bu esikleri ve agirliklari degistirebilir; Kaydet butonu ile `config.json` guncellenir ve motorlar yeniden kurulur. Bu ayarlar hem analiz kalitesini hem de kopya kararinin hassasiyetini belirler.

Analiz sirasinda GUI donmasin diye islem bir worker thread’de calisir. Ilerleme durumu progress bar ile guncellenir, log paneli ise hangi dosyalarin yüklendigi ve hangi ciftlerin analiz edildigi gibi mesajlari yazar. Iptal butonu ile islem kesilebilir; iptal olursa kismi sonuclar kaydedilebilir. Her analiz calismasi icin zaman damgasi uretilir ve bu run bilgisi `db/results.db` icinde saklanir. `db/database.py` icinde `results` tablosu ana skor kayitlarini tutar, `runs` tablosu run bazli meta bilgileri saklar, `evidences` tablosu ise parca bazli kanitlari (en benzer parcalar) kalici olarak depolar. Bu sayede uygulama kapanip acildiginda run gecmisi ve detaylar kaybolmaz.

Parca bazli kanit uretimi analiz sonrasinda her dokuman ciftinde yapilir. Metinler basit ayraclara gore parcalara bolunur; her parca cifti icin TF‑IDF tabanli benzerlik matrisi uretilir ve en yuksek top‑N eslesme secilir. Bu kanitlar DB’ye kaydedilir ve GUI’de sonuc tablosunda cift tiklama ile acilan detay penceresinde yan yana goruntulenir. Detay penceresi kaydirmaya gerek kalmadan metinleri iki sutunda gosterir ve skorlar ayri bir sutunda bulunur. Bu bolum, egitmenlerin kopya tespitinde “neden”i gorebilmesi icin tasarlanmistir.

Model secimi uygulamanin performansini etkiler. Heavy semantic model (paraphrase‑multilingual‑MiniLM‑L12‑v2) daha isabetli fakat daha agir, light model (distiluse‑base‑multilingual‑cased‑v1) daha hizlidir. OCR tarafinda da heavy/light/off secenekleri vardir; OCR kapatildiginda sadece PDF’in metin katmani kullanilir. Model dosyalari once indirildiginde `models/` klasoru altinda tutulur ve uygulama EXE olarak calistiginda da ayni klasor uzerinden offline kullanilir. `core/model_paths.py` bu davranisi saglar: model klasoru mevcutsa lokal yolu kullanir, degilse model ismiyle online indirme mekanizmasina doner.

Uygulama sonuclari CSV olarak disari aktarabilir veya veritabani temizlenebilir. Calisma gecmisi sol panelde tarih bazli listelenir; bir run secildiginde o run’a ait sonuclar tabloda gorunur. Performans olarak, dokuman sayisi arttikca karsilastirma sayisi katlanarak artar (N*(N-1)/2), bu nedenle buyuk setlerde OCR off ve light model secimi tavsiye edilir. Hata yakalama mekanizmalari dosya okuma, analiz ve DB islemlerini korur; olasi hatalar log paneline yazilir, uygulama cokmeden devam eder.

EXE paketleme PyInstaller ile yapilir ve `models/` ile `config.json` exe yanina eklenir. Kullanici `dist/main/main.exe` uzerinden calistirir ve offline olarak calisabilir. Modeller buyuk oldugu icin onedir paket yerine klasor yapisi tercih edilir. Bu sayede proje hem gelistirme ortaminda Python ile calisir hem de tek bir klasor olarak baska bilgisayarlara tasinabilir.
